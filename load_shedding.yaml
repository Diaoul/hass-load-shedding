blueprint:
  name: âš¡ Load Shedding
  description: |
    Proactive load management to prevent exceeding power capacity limits.

    Supports dynamic capacity via sensor input (e.g., solar + grid limit, time-of-use).

    **Features:**
    - âš¡ Real-time power monitoring
    - ðŸŽ¯ Order-based priority (unlimited levels)
    - ðŸ”„ Intelligent load restoration
    - ðŸ›¡ï¸ Configurable safety margins
    - ðŸš« Anti-flapping protection
    - ðŸ“ Structured load configuration

    **How it works:**
    1. Monitors total power consumption (e.g., from Linky meter)
    2. Makes instant shedding decisions when approaching capacity (default: 90%)
    3. Restores highest-priority loads when power drops (default: 80%)
    4. Prevents rapid on/off cycling with minimum shed duration (default: 5min) and hysteresis

    **Configuration:** Use the structured load form - only 2 global helpers required.

    **Requirements:** Home Assistant 2025.7.0 or later
  domain: automation
  input:
    power_monitoring:
      name: Power Monitoring
      icon: mdi:flash
      collapsed: false
      input:
        total_power_sensor:
          name: ðŸ“Š Total Power Consumption Sensor
          description: |
            Sensor measuring total household power consumption (e.g., Linky meter, whole-home energy monitor).

            If your meter reports VA (apparent power) instead of W (real power), create a template sensor to convert using your power factor.
          selector:
            entity:
              filter:
                - domain: sensor
                  device_class: power
              multiple: false

        max_power_sensor:
          name: âš¡ Max Power Capacity Sensor
          description: |
            Sensor or helper reporting maximum power capacity in Watts.

            Can be static (input_number helper) or dynamic (template sensor).

            **Static capacity:**
            - Create input_number helper with fixed value (e.g., 9000)

            **Dynamic capacity examples:**
            - Solar + Grid: Template sensor with `9000 + solar_power`
            - Time-of-use: Different limits by hour (off-peak vs peak)
            - Battery state: Higher limit when battery charged
          selector:
            entity:
              filter:
                - domain: sensor
                - domain: input_number
              multiple: false

        safety_margin_percent:
          name: ðŸ›¡ï¸ Safety Margin Percentage
          description: |
            Start shedding loads when consumption reaches this percentage of max capacity.
            Example: 90% means shed at 8100W if max is 9000W.
            Higher values = more proactive shedding.
          default: 90
          selector:
            number:
              min: 50
              max: 100
              step: 1
              unit_of_measurement: "%"
              mode: slider

        restoration_margin_percent:
          name: ðŸ”„ Restoration Margin Percentage
          description: |
            Only restore loads when consumption is below this percentage.
            Should be lower than safety margin to prevent flapping.
            Example: 80% means restore at 7200W if max is 9000W.
          default: 80
          selector:
            number:
              min: 50
              max: 100
              step: 1
              unit_of_measurement: "%"
              mode: slider

    load_configuration:
      name: Load Configuration
      icon: mdi:lightning-bolt-circle
      collapsed: false
      input:
        managed_loads:
          name: ðŸŽ¯ Managed Loads
          description: |
            Configure each load you want to manage.
            Click "Add Item" to add a new load.

            **Priority by order:** Top = highest priority (shed last), Bottom = lowest (shed first)

            **Fields:**
            - **Detection Entity**: Climate or switch that indicates if the load is consuming power
              - Climate: Detects ON when hvac_action is 'heating'/'cooling' (or sensor-based if configured)
              - Switch: Detects ON when state is 'on'
            - **Off Override**: Switch or input_boolean to disable the load
              - When ON: Load is disabled (shed)
              - When OFF: Load is enabled (can run normally)
            - **Estimated Power**: Rated power consumption in Watts
            - **Climate Detection Method** (optional): How to detect if climate is ON
              - hvac_action (accurate, recommended)
              - sensor_based (uses hvac_mode + temperature sensors)
          default: []
          selector:
            object:
              multiple: true
              label_field: detection_entity
              fields:
                detection_entity:
                  label: Detection Entity
                  selector:
                    entity:
                      filter:
                        - domain: climate
                        - domain: switch
                      multiple: false

                off_override:
                  label: Off Override
                  selector:
                    entity:
                      filter:
                        - domain: input_boolean
                      multiple: false

                max_power:
                  label: Maximum Power (Watts)
                  selector:
                    number:
                      min: 1
                      max: 50000
                      step: 1
                      unit_of_measurement: "W"
                      mode: box

                power_sensor:
                  label: Power Sensor (Optional)
                  selector:
                    entity:
                      filter:
                        - domain: sensor
                          device_class: power
                      multiple: false

                climate_detection:
                  label: Climate Detection Method (Optional)
                  selector:
                    select:
                      options:
                        - label: hvac_action (accurate, recommended)
                          value: hvac_action
                        - label: sensor_based (fallback)
                          value: sensor_based

    timing_and_stability:
      name: Timing & Stability
      icon: mdi:clock-outline
      collapsed: true
      input:
        minimum_shed_duration:
          name: â±ï¸ Minimum Shed Duration
          description: Once a load is shed, keep it off for at least this long (prevents rapid cycling)
          default:
            hours: 0
            minutes: 5
            seconds: 0
          selector:
            duration:
              enable_day: false

    tracking_helpers:
      name: Tracking Helpers (Required)
      icon: mdi:database
      collapsed: true
      input:
        last_action_datetime:
          name: â° Last Action DateTime Tracker
          description: |
            `required`

            Input datetime helper to track when last shed/restore action occurred.
            Used for minimum shed duration enforcement.

            **Initialize to any datetime (e.g., 1970-01-01 00:00:00).**

            Create helper [here](https://my.home-assistant.io/redirect/helpers/).
          selector:
            entity:
              filter:
                - domain: input_datetime
              multiple: false

variables:
  # Input assignments - power monitoring
  total_power_sensor: !input total_power_sensor
  max_power_sensor: !input max_power_sensor
  safety_margin: !input safety_margin_percent
  restoration_margin: !input restoration_margin_percent

  # Get max power from sensor (can be input_number or template sensor)
  max_power: "{{ states(max_power_sensor) | float(0) }}"

  # Input assignments - loads
  managed_loads: !input managed_loads

  # Input assignments - timing
  minimum_shed_duration: !input minimum_shed_duration

  # Input assignments - tracking
  last_action_datetime: !input last_action_datetime

  # Calculated thresholds
  shedding_threshold: "{{ (max_power * (safety_margin / 100)) | int }}"
  restoration_threshold: "{{ (max_power * (restoration_margin / 100)) | int }}"

  # Current state
  current_power: "{{ states(total_power_sensor) | float(0) }}"

  # Currently shed loads list (check off override states)
  currently_shed_loads: >-
    {% set ns = namespace(shed=[]) %}
    {% for load in managed_loads %}
      {% set override = load.get('off_override') %}
      {% if override and is_state(override, 'on') %}
        {% set ns.shed = ns.shed + [load.detection_entity] %}
      {% endif %}
    {% endfor %}
    {{ ns.shed }}

  # Last action timestamp
  last_action_time: >-
    {{ states(last_action_datetime) | as_datetime | as_local | as_timestamp }}

  # Time since last action
  seconds_since_last_action: >-
    {{ (now().timestamp() - last_action_time) | int }}

trigger:
  # Trigger on HA start
  - trigger: homeassistant
    event: start
    id: ha_start

  # Primary trigger: Power consumption changes
  - trigger: state
    entity_id: !input total_power_sensor
    id: power_changed

  # Secondary trigger: Periodic re-evaluation (failsafe)
  - trigger: time_pattern
    minutes: "/1"
    id: periodic_check

condition: []

action:
  # Validate configuration
  - condition: template
    value_template: >-
      {% if managed_loads | length == 0 %}
        {{ false }}
      {% endif %}

      {# Validate no duplicate detection entities #}
      {% set detection_entities = managed_loads | map(attribute='detection_entity') | list %}
      {% if detection_entities | unique | list | length != detection_entities | length %}
        {{ false }}
      {% endif %}

      {# Validate restoration margin is lower than safety margin #}
      {% if restoration_margin >= safety_margin %}
        {{ false }}
      {% endif %}

      {# Validate all loads have off_override (now mandatory) #}
      {% for load in managed_loads %}
        {% if not load.get('off_override') %}
          {{ false }}
        {% endif %}
      {% endfor %}

      {{ true }}

  # Determine mode (shedding or restoration)
  - variables:
      power_over_shedding_threshold: "{{ current_power > shedding_threshold }}"
      power_under_restoration_threshold: "{{ current_power < restoration_threshold }}"

  # SHEDDING MODE
  - if:
      - condition: template
        value_template: "{{ power_over_shedding_threshold }}"
    then:
      # Build candidate list for shedding (instant decision based on trigger)
      - variables:
          candidates_to_shed: >-
            {% set ns = namespace(candidates=[]) %}
            {% for load in managed_loads %}
              {% set detection_entity = load.detection_entity %}
              {% set off_override = load.get('off_override', '') %}
              {% set max_power = load.max_power | float(0) %}
              {% set load_index = loop.index0 %}

              {# Get actual power from sensor if available #}
              {% set actual_power = max_power %}
              {% set power_sensor = load.get('power_sensor', '') %}
              {% if power_sensor and power_sensor | length > 0 %}
                {% if states(power_sensor) not in ['unknown', 'unavailable'] %}
                  {% set sensor_value = states(power_sensor) | float(-1) %}
                  {# Use sensor value if valid (non-negative) #}
                  {% if sensor_value >= 0 %}
                    {% set actual_power = sensor_value %}
                  {% endif %}
                {% endif %}
              {% endif %}

              {# Skip if max_power invalid #}
              {% if max_power <= 0 %}
                {% continue %}
              {% endif %}

              {# Determine control entity (off_override is now mandatory) #}
              {% if off_override and off_override | length > 0 %}
                {% set control_entity = off_override %}
              {% else %}
                {% set control_entity = detection_entity %}
              {% endif %}

              {# Validate control entity exists #}
              {% if states(control_entity) in ['unknown', 'unavailable'] %}
                {% continue %}
              {% endif %}

              {# Determine if load is ON based on detection entity type #}
              {% set is_load_on = namespace(value=false) %}
              {% set entity_domain = detection_entity.split('.')[0] %}

              {% if entity_domain == 'climate' %}
                {# Get detection method (default to hvac_action) #}
                {% set detection_method = load.get('climate_detection', 'hvac_action') %}

                {% if detection_method == 'sensor_based' %}
                  {# Sensor-based: check hvac_mode + temperature delta #}
                  {% set hvac_mode = states(detection_entity) %}
                  {% set current_temp = state_attr(detection_entity, 'current_temperature') | float(0) %}
                  {% set target_temp = state_attr(detection_entity, 'temperature') | float(0) %}

                  {% if hvac_mode == 'heat' and current_temp < target_temp %}
                    {% set is_load_on.value = true %}
                  {% elif hvac_mode == 'cool' and current_temp > target_temp %}
                    {% set is_load_on.value = true %}
                  {% elif hvac_mode in ['heat_cool', 'auto'] %}
                    {% if current_temp < target_temp or current_temp > target_temp %}
                      {% set is_load_on.value = true %}
                    {% endif %}
                  {% endif %}
                {% else %}
                  {# Default: check hvac_action attribute #}
                  {% set hvac_action = state_attr(detection_entity, 'hvac_action') %}
                  {% if hvac_action in ['heating', 'cooling'] %}
                    {% set is_load_on.value = true %}
                  {% endif %}
                {% endif %}
              {% elif entity_domain == 'switch' %}
                {# For switch: check state #}
                {% if is_state(detection_entity, 'on') %}
                  {% set is_load_on.value = true %}
                {% endif %}
              {% endif %}

              {# Add to candidates #}
              {% set ns.candidates = ns.candidates + [{
                'entity_id': detection_entity,
                'index': load_index,
                'power': actual_power,
                'max_power': max_power,
                'control': control_entity
              }] %}
            {% endfor %}

            {# Sort by index (descending) then power (descending) #}
            {% set sorted_by_power = ns.candidates | sort(attribute='power', reverse=true) %}
            {{ sorted_by_power | sort(attribute='index', reverse=true) }}

          # Calculate deficit
          power_deficit: "{{ current_power - shedding_threshold }}"

      # Shed loads iteratively
      - variables:
          remaining_deficit: "{{ power_deficit }}"
          shed_any: false

      - repeat:
          for_each: "{{ candidates_to_shed }}"
          sequence:
            # Only shed if still needed
            - condition: template
              value_template: "{{ remaining_deficit > 0 }}"

            # Update deficit and tracking
            - variables:
                remaining_deficit: "{{ (remaining_deficit - repeat.item.power) | float }}"
                shed_any: true

            # Enable off override (turn ON = disable load)
            - service: homeassistant.turn_on
              target:
                entity_id: "{{ repeat.item.control }}"

      # Update last action time if any loads were shed
      - if:
          - condition: template
            value_template: "{{ shed_any }}"
        then:
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ last_action_datetime }}"
            data:
              datetime: "{{ now() }}"

  # RESTORATION MODE
  - if:
      - condition: template
        value_template: "{{ power_under_restoration_threshold and currently_shed_loads | length > 0 }}"
    then:
      # Check minimum shed duration (instant decision based on trigger)
      - condition: template
        value_template: >-
          {{ seconds_since_last_action >= timedelta(**minimum_shed_duration).total_seconds() }}

      # Build restoration candidates (check which off overrides are ON)
      - variables:
          candidates_to_restore: >-
            {% set ns = namespace(candidates=[]) %}

            {% for load in managed_loads %}
              {% set detection_entity = load.detection_entity %}
              {% set off_override = load.get('off_override', '') %}
              {% set max_power = load.max_power | float(0) %}
              {% set load_index = loop.index0 %}

              {# Skip if max_power invalid #}
              {% if max_power <= 0 %}
                {% continue %}
              {% endif %}

              {# Off override is now mandatory #}
              {% set control_entity = off_override %}

              {# Skip if control is not ON (= not shed) #}
              {% if not is_state(control_entity, 'on') %}
                {% continue %}
              {% endif %}

              {# Validate control entity exists #}
              {% if states(control_entity) in ['unknown', 'unavailable'] %}
                {% continue %}
              {% endif %}

              {# Determine if load is OFF based on detection entity type #}
              {% set is_load_off = namespace(value=false) %}
              {% set entity_domain = detection_entity.split('.')[0] %}

              {% if entity_domain == 'climate' %}
                {# Get detection method (default to hvac_action) #}
                {% set detection_method = load.get('climate_detection', 'hvac_action') %}

                {% if detection_method == 'sensor_based' %}
                  {# Sensor-based: check hvac_mode + temperature delta #}
                  {% set hvac_mode = states(detection_entity) %}
                  {% set current_temp = state_attr(detection_entity, 'current_temperature') | float(0) %}
                  {% set target_temp = state_attr(detection_entity, 'temperature') | float(0) %}

                  {% if hvac_mode == 'off' %}
                    {% set is_load_off.value = true %}
                  {% elif hvac_mode == 'heat' and current_temp >= target_temp %}
                    {% set is_load_off.value = true %}
                  {% elif hvac_mode == 'cool' and current_temp <= target_temp %}
                    {% set is_load_off.value = true %}
                  {% elif hvac_mode in ['heat_cool', 'auto'] and current_temp == target_temp %}
                    {% set is_load_off.value = true %}
                  {% endif %}
                {% else %}
                  {# Default: check hvac_action attribute #}
                  {% set hvac_action = state_attr(detection_entity, 'hvac_action') %}
                  {% if hvac_action in ['idle', 'off'] or hvac_action is none %}
                    {% set is_load_off.value = true %}
                  {% endif %}
                {% endif %}
              {% elif entity_domain == 'switch' %}
                {# For switch: check state #}
                {% if is_state(detection_entity, 'off') %}
                  {% set is_load_off.value = true %}
                {% endif %}
              {% endif %}

              {# Skip if load is not OFF #}
              {% if not is_load_off.value %}
                {% continue %}
              {% endif %}

              {# Add to candidates #}
              {% set ns.candidates = ns.candidates + [{
                'entity_id': detection_entity,
                'index': load_index,
                'power': max_power,
                'control': control_entity
              }] %}
            {% endfor %}

            {# Sort by index (ascending) then power (ascending) #}
            {% set sorted_by_power = ns.candidates | sort(attribute='power') %}
            {{ sorted_by_power | sort(attribute='index') }}

          # Calculate available budget
          available_budget: "{{ restoration_threshold - current_power }}"

      # Restore loads iteratively
      - variables:
          power_accumulator: "{{ current_power }}"
          restored_any: false

      - repeat:
          for_each: "{{ candidates_to_restore }}"
          sequence:
            # Check if we have budget for this load
            - condition: template
              value_template: "{{ repeat.item.power <= (restoration_threshold - power_accumulator) }}"

            # Update accumulator and tracking
            - variables:
                power_accumulator: "{{ (power_accumulator + repeat.item.power) | float }}"
                restored_any: true

            # Disable off override (turn OFF = enable load)
            - service: homeassistant.turn_off
              target:
                entity_id: "{{ repeat.item.control }}"

      # Update last action time if any loads were restored
      - if:
          - condition: template
            value_template: "{{ restored_any }}"
        then:
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ last_action_datetime }}"
            data:
              datetime: "{{ now() }}"

mode: single
