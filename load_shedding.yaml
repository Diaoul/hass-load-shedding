blueprint:
  name: âš¡ Load Shedding
  description: |
    Proactive load management to prevent exceeding power capacity limits.

    Supports dynamic capacity via sensor input (e.g., solar + grid limit, time-of-use).

    **Features:**
    - âš¡ Real-time power monitoring
    - ðŸŽ¯ Order-based priority (unlimited levels)
    - ðŸ”„ Intelligent load restoration
    - ðŸ›¡ï¸ Configurable safety margins
    - ðŸš« Anti-flapping protection
    - ðŸ“ Structured load configuration

    **How it works:**
    1. Monitors total power consumption (e.g., from Linky meter)
    2. Sheds lowest-priority loads when approaching capacity (default: 90%)
    3. Restores highest-priority loads when power drops (default: 80%)
    4. Prevents rapid on/off cycling with time delays and hysteresis

    **Configuration:** Use the structured load form - only 2 global helpers required.

    **Requirements:** Home Assistant 2025.7.0 or later
  domain: automation
  input:
    power_monitoring:
      name: Power Monitoring
      icon: mdi:flash
      collapsed: false
      input:
        total_power_sensor:
          name: ðŸ“Š Total Power Consumption Sensor
          description: |
            Sensor measuring total household power consumption (e.g., Linky meter, whole-home energy monitor).

            If your meter reports VA (apparent power) instead of W (real power), create a template sensor to convert using your power factor.
          selector:
            entity:
              filter:
                - domain: sensor
                  device_class: power
              multiple: false

        max_power_sensor:
          name: âš¡ Max Power Capacity Sensor
          description: |
            Sensor or helper reporting maximum power capacity in Watts.

            Can be static (input_number helper) or dynamic (template sensor).

            **Static capacity:**
            - Create input_number helper with fixed value (e.g., 9000)

            **Dynamic capacity examples:**
            - Solar + Grid: Template sensor with `9000 + solar_power`
            - Time-of-use: Different limits by hour (off-peak vs peak)
            - Battery state: Higher limit when battery charged
          selector:
            entity:
              filter:
                - domain: sensor
                - domain: input_number
              multiple: false

        safety_margin_percent:
          name: ðŸ›¡ï¸ Safety Margin Percentage
          description: |
            Start shedding loads when consumption reaches this percentage of max capacity.
            Example: 90% means shed at 8100W if max is 9000W.
            Higher values = more proactive shedding.
          default: 90
          selector:
            number:
              min: 50
              max: 100
              step: 1
              unit_of_measurement: "%"
              mode: slider

        restoration_margin_percent:
          name: ðŸ”„ Restoration Margin Percentage
          description: |
            Only restore loads when consumption is below this percentage.
            Should be lower than safety margin to prevent flapping.
            Example: 80% means restore at 7200W if max is 9000W.
          default: 80
          selector:
            number:
              min: 50
              max: 100
              step: 1
              unit_of_measurement: "%"
              mode: slider

    load_configuration:
      name: Load Configuration
      icon: mdi:lightning-bolt-circle
      collapsed: false
      input:
        managed_loads:
          name: ðŸŽ¯ Managed Loads
          description: |
            Configure each load you want to manage.
            Click "Add Item" to add a new load.

            **Priority by order:** Top = highest priority (shed last), Bottom = lowest (shed first)

            **Fields:**
            - **Primary Entity**: Climate or switch that indicates load status
              - Climate: Sheds when hvac_action is 'heating'/'cooling' (or sensor-based if configured)
              - Switch: Sheds when state is 'on'
            - **Control Switch** (optional): Switch or input_boolean to actually control the load
              - If set: Uses this switch for on/off control
              - If empty: Controls primary entity directly
            - **Estimated Power**: Rated power consumption in Watts
            - **Climate Detection Method** (optional): How to detect if climate is ON
              - hvac_action (accurate, recommended)
              - sensor_based (uses hvac_mode + temperature sensors)
          default: []
          selector:
            object:
              multiple: true
              label_field: primary_entity
              fields:
                primary_entity:
                  label: Primary Entity
                  selector:
                    entity:
                      filter:
                        - domain: climate
                        - domain: switch
                      multiple: false

                control_switch:
                  label: Control Switch (Optional)
                  selector:
                    entity:
                      filter:
                        - domain: switch
                        - domain: input_boolean
                      multiple: false

                max_power:
                  label: Estimated Power (Watts)
                  selector:
                    number:
                      min: 1
                      max: 50000
                      step: 1
                      unit_of_measurement: "W"
                      mode: box

                climate_detection:
                  label: Climate Detection Method (Optional)
                  selector:
                    select:
                      options:
                        - label: hvac_action (accurate, recommended)
                          value: hvac_action
                        - label: sensor_based (fallback)
                          value: sensor_based

    timing_and_stability:
      name: Timing & Stability
      icon: mdi:clock-outline
      collapsed: true
      input:
        shedding_delay:
          name: â±ï¸ Shedding Delay
          description: Wait this long after exceeding threshold before shedding (prevents transient spikes from causing shedding)
          default:
            hours: 0
            minutes: 0
            seconds: 10
          selector:
            duration:
              enable_day: false

        restoration_delay:
          name: â±ï¸ Restoration Delay
          description: Wait this long after dropping below threshold before restoring loads
          default:
            hours: 0
            minutes: 1
            seconds: 0
          selector:
            duration:
              enable_day: false

        minimum_shed_duration:
          name: â±ï¸ Minimum Shed Duration
          description: Once a load is shed, keep it off for at least this long (prevents rapid cycling)
          default:
            hours: 0
            minutes: 5
            seconds: 0
          selector:
            duration:
              enable_day: false

    tracking_helpers:
      name: Tracking Helpers (Required)
      icon: mdi:database
      collapsed: true
      input:
        shed_loads_tracker:
          name: ðŸ“ Currently Shed Loads Tracker
          description: |
            `required`

            Input text helper to track which loads are currently shed by automation.
            Stores JSON array of entity IDs (e.g., ["climate.bedroom", "switch.ev_charger"]).

            **Initialize as empty string.**

            Create helper [here](https://my.home-assistant.io/redirect/helpers/).
          selector:
            entity:
              filter:
                - domain: input_text
              multiple: false

        last_action_datetime:
          name: â° Last Action DateTime Tracker
          description: |
            `required`

            Input datetime helper to track when last shed/restore action occurred.
            Used for minimum shed duration enforcement.

            **Initialize to any datetime (e.g., 1970-01-01 00:00:00).**

            Create helper [here](https://my.home-assistant.io/redirect/helpers/).
          selector:
            entity:
              filter:
                - domain: input_datetime
              multiple: false

variables:
  # Input assignments - power monitoring
  total_power_sensor: !input total_power_sensor
  max_power_sensor: !input max_power_sensor
  safety_margin: !input safety_margin_percent
  restoration_margin: !input restoration_margin_percent

  # Get max power from sensor (can be input_number or template sensor)
  max_power: "{{ states(max_power_sensor) | float(0) }}"

  # Input assignments - loads
  managed_loads: !input managed_loads

  # Input assignments - timing
  shedding_delay: !input shedding_delay
  restoration_delay: !input restoration_delay
  minimum_shed_duration: !input minimum_shed_duration

  # Input assignments - tracking
  shed_loads_tracker: !input shed_loads_tracker
  last_action_datetime: !input last_action_datetime

  # Calculated thresholds
  shedding_threshold: "{{ (max_power * (safety_margin / 100)) | int }}"
  restoration_threshold: "{{ (max_power * (restoration_margin / 100)) | int }}"

  # Current state
  current_power: "{{ states(total_power_sensor) | float(0) }}"

  # Currently shed loads list (parse JSON array of load names)
  currently_shed_loads: >-
    {% set shed_json = states(shed_loads_tracker) %}
    {% if shed_json in ['', 'unknown', 'unavailable'] %}
      []
    {% else %}
      {{ shed_json | from_json | default([]) }}
    {% endif %}

  # Last action timestamp
  last_action_time: >-
    {{ states(last_action_datetime) | as_datetime | as_local | as_timestamp }}

  # Time since last action
  seconds_since_last_action: >-
    {{ (now().timestamp() - last_action_time) | int }}

trigger:
  # Trigger on HA start
  - trigger: homeassistant
    event: start
    id: ha_start

  # Primary trigger: Power consumption changes
  - trigger: state
    entity_id: !input total_power_sensor
    id: power_changed

  # Secondary trigger: Periodic re-evaluation (failsafe)
  - trigger: time_pattern
    minutes: "/1"
    id: periodic_check

condition: []

action:
  # Initialize trackers on HA start
  - if:
      - condition: template
        value_template: "{{ trigger.id == 'ha_start' }}"
    then:
      # Initialize shed tracker if empty/invalid
      - if:
          - condition: template
            value_template: "{{ states(shed_loads_tracker) in ['', 'unknown', 'unavailable'] }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ shed_loads_tracker }}"
            data:
              value: "[]"

      # Clean up orphaned entity IDs from tracker
      - variables:
          valid_entity_ids: "{{ managed_loads | map(attribute='primary_entity') | list }}"
          current_shed_loads_list: >-
            {% set shed_json = states(shed_loads_tracker) %}
            {% if shed_json in ['', 'unknown', 'unavailable'] %}
              []
            {% else %}
              {{ shed_json | from_json | default([]) }}
            {% endif %}
          cleaned_shed_loads: >-
            {{ current_shed_loads_list | select('in', valid_entity_ids) | list }}

      # Update tracker if we removed any orphans
      - if:
          - condition: template
            value_template: "{{ current_shed_loads_list | length != cleaned_shed_loads | length }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ shed_loads_tracker }}"
            data:
              value: "{{ cleaned_shed_loads | to_json }}"

  # Validate configuration
  - condition: template
    value_template: >-
      {% if managed_loads | length == 0 %}
        {{ false }}
      {% endif %}

      {# Validate no duplicate primary entities #}
      {% set primary_entities = managed_loads | map(attribute='primary_entity') | list %}
      {% if primary_entities | unique | list | length != primary_entities | length %}
        {{ false }}
      {% endif %}

      {# Validate restoration margin is lower than safety margin #}
      {% if restoration_margin >= safety_margin %}
        {{ false }}
      {% endif %}

      {{ true }}

  # Clean up orphaned entities from tracker
  - variables:
      valid_entity_ids: "{{ managed_loads | map(attribute='primary_entity') | list }}"
      cleaned_shed_loads: "{{ currently_shed_loads | select('in', valid_entity_ids) | list }}"

  - if:
      - condition: template
        value_template: "{{ currently_shed_loads | length != cleaned_shed_loads | length }}"
    then:
      - service: input_text.set_value
        target:
          entity_id: "{{ shed_loads_tracker }}"
        data:
          value: "{{ cleaned_shed_loads | to_json }}"

      # Update currently_shed_loads variable for this run
      - variables:
          currently_shed_loads: "{{ cleaned_shed_loads }}"

  # Determine mode (shedding or restoration)
  - variables:
      power_over_shedding_threshold: "{{ current_power > shedding_threshold }}"
      power_under_restoration_threshold: "{{ current_power < restoration_threshold }}"

  # SHEDDING MODE
  - if:
      - condition: template
        value_template: "{{ power_over_shedding_threshold }}"
    then:
      # Wait for shedding delay to prevent transient spike reactions
      - if:
          - condition: template
            value_template: "{{ trigger.id == 'power_changed' }}"
        then:
          - delay: !input shedding_delay

      # Re-check power after delay (might have dropped)
      - variables:
          current_power_after_delay: "{{ states(total_power_sensor) | float(0) }}"

      - if:
          - condition: template
            value_template: "{{ current_power_after_delay > shedding_threshold }}"
        then:
          # Build candidate list for shedding
          - variables:
              candidates_to_shed: >-
                {% set ns = namespace(candidates=[]) %}
                {% for load in managed_loads %}
                  {% set primary_entity = load.primary_entity %}
                  {% set control_switch = load.get('control_switch', '') %}
                  {% set max_power = load.max_power | float(0) %}
                  {% set load_index = loop.index0 %}

                  {# Skip if max_power invalid #}
                  {% if max_power <= 0 %}
                    {% continue %}
                  {% endif %}

                  {# Determine control entity #}
                  {% if control_switch and control_switch | length > 0 %}
                    {% set control_entity = control_switch %}
                  {% else %}
                    {% set control_entity = primary_entity %}
                  {% endif %}

                  {# Validate control entity exists #}
                  {% if states(control_entity) in ['unknown', 'unavailable'] %}
                    {% continue %}
                  {% endif %}

                  {# Determine if load is ON based on primary entity type #}
                  {% set is_load_on = namespace(value=false) %}
                  {% set entity_domain = primary_entity.split('.')[0] %}

                  {% if entity_domain == 'climate' %}
                    {# Get detection method (default to hvac_action) #}
                    {% set detection_method = load.get('climate_detection', 'hvac_action') %}

                    {% if detection_method == 'sensor_based' %}
                      {# Sensor-based: check hvac_mode + temperature delta #}
                      {% set hvac_mode = states(primary_entity) %}
                      {% set current_temp = state_attr(primary_entity, 'current_temperature') | float(0) %}
                      {% set target_temp = state_attr(primary_entity, 'temperature') | float(0) %}

                      {% if hvac_mode == 'heat' and current_temp < target_temp %}
                        {% set is_load_on.value = true %}
                      {% elif hvac_mode == 'cool' and current_temp > target_temp %}
                        {% set is_load_on.value = true %}
                      {% elif hvac_mode in ['heat_cool', 'auto'] %}
                        {% if current_temp < target_temp or current_temp > target_temp %}
                          {% set is_load_on.value = true %}
                        {% endif %}
                      {% endif %}
                    {% else %}
                      {# Default: check hvac_action attribute #}
                      {% set hvac_action = state_attr(primary_entity, 'hvac_action') %}
                      {% if hvac_action in ['heating', 'cooling'] %}
                        {% set is_load_on.value = true %}
                      {% endif %}
                    {% endif %}
                  {% elif entity_domain == 'switch' %}
                    {# For switch: check state #}
                    {% if is_state(primary_entity, 'on') %}
                      {% set is_load_on.value = true %}
                    {% endif %}
                  {% endif %}

                  {# Skip if load is not ON #}
                  {% if not is_load_on.value %}
                    {% continue %}
                  {% endif %}

                  {# Add to candidates #}
                  {% set ns.candidates = ns.candidates + [{
                    'entity_id': primary_entity,
                    'index': load_index,
                    'power': max_power,
                    'control': control_entity
                  }] %}
                {% endfor %}

                {# Sort by index (descending) then power (descending) #}
                {% set sorted_by_power = ns.candidates | sort(attribute='power', reverse=true) %}
                {{ sorted_by_power | sort(attribute='index', reverse=true) }}

              # Calculate deficit
              power_deficit: "{{ current_power_after_delay - shedding_threshold }}"

          # Shed loads iteratively
          - variables:
              shed_entities: []
              remaining_deficit: "{{ power_deficit }}"

          - repeat:
              for_each: "{{ candidates_to_shed }}"
              sequence:
                # Only shed if still needed
                - condition: template
                  value_template: "{{ remaining_deficit > 0 }}"

                # Turn off control entity
                - service: homeassistant.turn_off
                  target:
                    entity_id: "{{ repeat.item.control }}"

                # Track this shed load
                - variables:
                    shed_entities: "{{ shed_entities + [repeat.item.entity_id] }}"
                    remaining_deficit: "{{ (remaining_deficit - repeat.item.power) | float }}"

          # Update tracker with newly shed loads
          - if:
              - condition: template
                value_template: "{{ shed_entities | length > 0 }}"
            then:
              - variables:
                  all_shed_loads: "{{ (currently_shed_loads + shed_entities) | unique | list }}"

              - service: input_text.set_value
                target:
                  entity_id: "{{ shed_loads_tracker }}"
                data:
                  value: "{{ all_shed_loads | to_json }}"

              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ last_action_datetime }}"
                data:
                  datetime: "{{ now() }}"

  # RESTORATION MODE
  - if:
      - condition: template
        value_template: "{{ power_under_restoration_threshold and currently_shed_loads | length > 0 }}"
    then:
      # Wait for restoration delay
      - if:
          - condition: template
            value_template: "{{ trigger.id == 'power_changed' }}"
        then:
          - delay: !input restoration_delay

      # Re-check power after delay (might have increased)
      - variables:
          current_power_after_delay: "{{ states(total_power_sensor) | float(0) }}"

      - if:
          - condition: template
            value_template: "{{ current_power_after_delay < restoration_threshold }}"
        then:
          # Check minimum shed duration
          - condition: template
            value_template: >-
              {{ seconds_since_last_action >= timedelta(**minimum_shed_duration).total_seconds() }}

          # Build restoration candidates
          - variables:
              candidates_to_restore: >-
                {% set ns = namespace(candidates=[]) %}

                {# Build lookup dictionary once - O(M) #}
                {% set load_lookup = namespace(dict={}) %}
                {% for load in managed_loads %}
                  {% set _ = load_lookup.dict.__setitem__(load.primary_entity, {
                    'load': load,
                    'index': loop.index0
                  }) %}
                {% endfor %}

                {# Lookup each shed load - O(N) instead of O(NÃ—M) #}
                {% for entity_id in currently_shed_loads %}
                  {# Direct lookup instead of nested loop #}
                  {% if entity_id in load_lookup.dict %}
                    {% set load_info = load_lookup.dict[entity_id] %}
                    {% set load_obj = load_info['load'] %}
                    {% set load_index = load_info['index'] %}

                    {% set primary_entity = load_obj.primary_entity %}
                    {% set control_switch = load_obj.get('control_switch', '') %}
                    {% set max_power = load_obj.max_power | float(0) %}

                    {# Skip if max_power invalid #}
                    {% if max_power <= 0 %}
                      {% continue %}
                    {% endif %}

                    {# Determine control entity #}
                    {% if control_switch and control_switch | length > 0 %}
                      {% set control_entity = control_switch %}
                    {% else %}
                      {% set control_entity = primary_entity %}
                    {% endif %}

                    {# Validate control entity exists #}
                    {% if states(control_entity) in ['unknown', 'unavailable'] %}
                      {% continue %}
                    {% endif %}

                    {# Determine if load is OFF based on primary entity type #}
                    {% set is_load_off = namespace(value=false) %}
                    {% set entity_domain = primary_entity.split('.')[0] %}

                    {% if entity_domain == 'climate' %}
                      {# Get detection method (default to hvac_action) #}
                      {% set detection_method = load_obj.get('climate_detection', 'hvac_action') %}

                      {% if detection_method == 'sensor_based' %}
                        {# Sensor-based: check hvac_mode + temperature delta #}
                        {% set hvac_mode = states(primary_entity) %}
                        {% set current_temp = state_attr(primary_entity, 'current_temperature') | float(0) %}
                        {% set target_temp = state_attr(primary_entity, 'temperature') | float(0) %}

                        {% if hvac_mode == 'off' %}
                          {% set is_load_off.value = true %}
                        {% elif hvac_mode == 'heat' and current_temp >= target_temp %}
                          {% set is_load_off.value = true %}
                        {% elif hvac_mode == 'cool' and current_temp <= target_temp %}
                          {% set is_load_off.value = true %}
                        {% elif hvac_mode in ['heat_cool', 'auto'] and current_temp == target_temp %}
                          {% set is_load_off.value = true %}
                        {% endif %}
                      {% else %}
                        {# Default: check hvac_action attribute #}
                        {% set hvac_action = state_attr(primary_entity, 'hvac_action') %}
                        {% if hvac_action in ['idle', 'off'] or hvac_action is none %}
                          {% set is_load_off.value = true %}
                        {% endif %}
                      {% endif %}
                    {% elif entity_domain == 'switch' %}
                      {# For switch: check state #}
                      {% if is_state(primary_entity, 'off') %}
                        {% set is_load_off.value = true %}
                      {% endif %}
                    {% endif %}

                    {# Skip if load is not OFF #}
                    {% if not is_load_off.value %}
                      {% continue %}
                    {% endif %}

                    {# Add to candidates #}
                    {% set ns.candidates = ns.candidates + [{
                      'entity_id': primary_entity,
                      'index': load_index,
                      'power': max_power,
                      'control': control_entity
                    }] %}
                  {% endif %}
                {% endfor %}

                {# Sort by index (ascending) then power (ascending) #}
                {% set sorted_by_power = ns.candidates | sort(attribute='power') %}
                {{ sorted_by_power | sort(attribute='index') }}

              # Calculate available budget
              available_budget: "{{ restoration_threshold - current_power_after_delay }}"

          # Restore loads iteratively
          - variables:
              power_accumulator: "{{ current_power_after_delay }}"
              restored_entities: []

          - repeat:
              for_each: "{{ candidates_to_restore }}"
              sequence:
                # Check if we have budget for this load
                - condition: template
                  value_template: "{{ repeat.item.power <= (restoration_threshold - power_accumulator) }}"

                # Turn on control entity
                - service: homeassistant.turn_on
                  target:
                    entity_id: "{{ repeat.item.control }}"

                # Track restoration
                - variables:
                    power_accumulator: "{{ (power_accumulator + repeat.item.power) | float }}"
                    restored_entities: "{{ restored_entities + [repeat.item.entity_id] }}"

          # Update tracker (remove restored loads)
          - if:
              - condition: template
                value_template: "{{ restored_entities | length > 0 }}"
            then:
              - variables:
                  remaining_shed_loads: >-
                    {{ currently_shed_loads | reject('in', restored_entities) | list }}

              - service: input_text.set_value
                target:
                  entity_id: "{{ shed_loads_tracker }}"
                data:
                  value: "{{ remaining_shed_loads | to_json }}"

              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ last_action_datetime }}"
                data:
                  datetime: "{{ now() }}"

mode: queued
max: 10
max_exceeded: silent
