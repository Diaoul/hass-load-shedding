blueprint:
  name: âš¡ Intelligent Load Shedding
  description: |
    Proactive load management to prevent exceeding power capacity limits.

    **Features:**
    - âš¡ Real-time power monitoring
    - ðŸŽ¯ Priority-based load shedding (5 levels)
    - ðŸ”„ Intelligent load restoration
    - ðŸ›¡ï¸ Configurable safety margins
    - ðŸš« Anti-flapping protection
    - ðŸ”“ Manual override support
    - ðŸ“ Structured load configuration

    **How it works:**
    1. Monitors total power consumption (e.g., from Linky meter)
    2. Sheds lowest-priority loads when approaching capacity (default: 90%)
    3. Restores highest-priority loads when power drops (default: 80%)
    4. Prevents rapid on/off cycling with time delays and hysteresis

    **Configuration:** Use the structured load form - only 2 global helpers required.

    **Requirements:** Home Assistant 2025.7.0 or later
  domain: automation
  input:
    power_monitoring:
      name: Power Monitoring
      icon: mdi:flash
      collapsed: false
      input:
        total_power_sensor:
          name: ðŸ“Š Total Power Consumption Sensor
          description: Sensor measuring total household power consumption (e.g., Linky meter, whole-home energy monitor)
          selector:
            entity:
              filter:
                - domain: sensor
                  device_class: power
              multiple: false

        max_power_capacity:
          name: ðŸ”Œ Maximum Power Capacity
          description: Maximum power capacity in Watts (e.g., 9000W for 45A @ 230V single-phase, 12000W for 60A)
          default: 9000
          selector:
            number:
              min: 1000
              max: 50000
              step: 100
              unit_of_measurement: "W"
              mode: box

        safety_margin_percent:
          name: ðŸ›¡ï¸ Safety Margin Percentage
          description: |
            Start shedding loads when consumption reaches this percentage of max capacity.
            Example: 90% means shed at 8100W if max is 9000W.
            Higher values = more proactive shedding.
          default: 90
          selector:
            number:
              min: 50
              max: 100
              step: 1
              unit_of_measurement: "%"
              mode: slider

        restoration_margin_percent:
          name: ðŸ”„ Restoration Margin Percentage
          description: |
            Only restore loads when consumption is below this percentage.
            Should be lower than safety margin to prevent flapping.
            Example: 80% means restore at 7200W if max is 9000W.
          default: 80
          selector:
            number:
              min: 50
              max: 100
              step: 1
              unit_of_measurement: "%"
              mode: slider

    load_configuration:
      name: Load Configuration
      icon: mdi:lightning-bolt-circle
      collapsed: false
      input:
        managed_loads:
          name: ðŸŽ¯ Managed Loads
          description: |
            Configure each load you want to manage.
            Click "Add Item" to add a new load.

            **Priority by order:** Top = highest priority (shed last), Bottom = lowest (shed first)

            **Fields:**
            - **Primary Entity**: Climate or switch that indicates load status
              - Climate: Sheds when hvac_action is 'heating' or 'cooling'
              - Switch: Sheds when state is 'on'
            - **Control Switch** (optional): Switch to actually control the load
              - If set: Uses this switch for on/off control
              - If empty: Controls primary entity directly
            - **Estimated Power**: Rated power consumption in Watts
          default: []
          selector:
            object:
              multiple: true
              label_field: primary_entity
              fields:
                primary_entity:
                  label: Primary Entity
                  selector:
                    entity:
                      filter:
                        - domain: climate
                        - domain: switch
                      multiple: false

                control_switch:
                  label: Control Switch (Optional)
                  selector:
                    entity:
                      domain: switch
                      multiple: false

                max_power:
                  label: Estimated Power (Watts)
                  selector:
                    number:
                      min: 1
                      max: 50000
                      step: 1
                      unit_of_measurement: "W"
                      mode: box

    timing_and_stability:
      name: Timing & Stability
      icon: mdi:clock-outline
      collapsed: true
      input:
        shedding_delay:
          name: â±ï¸ Shedding Delay
          description: Wait this long after exceeding threshold before shedding (prevents transient spikes from causing shedding)
          default:
            hours: 0
            minutes: 0
            seconds: 10
          selector:
            duration:
              enable_day: false

        restoration_delay:
          name: â±ï¸ Restoration Delay
          description: Wait this long after dropping below threshold before restoring loads
          default:
            hours: 0
            minutes: 1
            seconds: 0
          selector:
            duration:
              enable_day: false

        minimum_shed_duration:
          name: â±ï¸ Minimum Shed Duration
          description: Once a load is shed, keep it off for at least this long (prevents rapid cycling)
          default:
            hours: 0
            minutes: 5
            seconds: 0
          selector:
            duration:
              enable_day: false

    manual_overrides:
      name: Manual Overrides
      icon: mdi:hand-back-right
      collapsed: true
      input:
        load_shedding_disable:
          name: ðŸ›‘ Disable Load Shedding
          description: |
            Toggle to completely disable load shedding.
            When enabled, all shed loads are immediately restored.

            Create a helper [here](https://my.home-assistant.io/redirect/helpers/).
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - input_boolean
                    - switch
                    - binary_sensor
              multiple: false

    tracking_helpers:
      name: Tracking Helpers (Required)
      icon: mdi:database
      collapsed: true
      input:
        shed_loads_tracker:
          name: ðŸ“ Currently Shed Loads Tracker
          description: |
            `required`

            Input text helper to track which loads are currently shed by automation.
            Stores JSON array of load names (e.g., ["Water Heater", "EV Charger"]).

            **Initialize as empty string.**

            Create helper [here](https://my.home-assistant.io/redirect/helpers/).
          selector:
            entity:
              filter:
                - domain: input_text
              multiple: false

        last_action_datetime:
          name: â° Last Action DateTime Tracker
          description: |
            `required`

            Input datetime helper to track when last shed/restore action occurred.
            Used for minimum shed duration enforcement.

            **Initialize to any datetime (e.g., 1970-01-01 00:00:00).**

            Create helper [here](https://my.home-assistant.io/redirect/helpers/).
          selector:
            entity:
              filter:
                - domain: input_datetime
              multiple: false

variables:
  # Input assignments - power monitoring
  total_power_sensor: !input total_power_sensor
  max_power: !input max_power_capacity
  safety_margin: !input safety_margin_percent
  restoration_margin: !input restoration_margin_percent

  # Input assignments - loads
  managed_loads: !input managed_loads

  # Input assignments - timing
  shedding_delay: !input shedding_delay
  restoration_delay: !input restoration_delay
  minimum_shed_duration: !input minimum_shed_duration

  # Input assignments - overrides
  load_shedding_disable: !input load_shedding_disable

  # Input assignments - tracking
  shed_loads_tracker: !input shed_loads_tracker
  last_action_datetime: !input last_action_datetime

  # Calculated thresholds
  shedding_threshold: "{{ (max_power * (safety_margin / 100)) | int }}"
  restoration_threshold: "{{ (max_power * (restoration_margin / 100)) | int }}"

  # Current state
  current_power: "{{ states(total_power_sensor) | float(0) }}"
  load_shedding_disabled: >-
    {{ load_shedding_disable | length > 0 and is_state(load_shedding_disable, 'on') }}

  # Currently shed loads list (parse JSON array of load names)
  currently_shed_loads: >-
    {% set shed_json = states(shed_loads_tracker) %}
    {% if shed_json in ['', 'unknown', 'unavailable'] %}
      []
    {% else %}
      {{ shed_json | from_json | default([]) }}
    {% endif %}

  # Last action timestamp
  last_action_time: >-
    {% set dt_state = states(last_action_datetime) %}
    {% if dt_state in ['unknown', 'unavailable'] %}
      {{ as_timestamp('1970-01-01 00:00:00') }}
    {% else %}
      {{ as_timestamp(dt_state) }}
    {% endif %}

  # Time since last action
  seconds_since_last_action: >-
    {{ (now().timestamp() - last_action_time) | int }}

trigger:
  # Trigger on HA start
  - trigger: homeassistant
    event: start
    id: ha_start

  # Primary trigger: Power consumption changes
  - trigger: state
    entity_id: !input total_power_sensor
    id: power_changed

  # Secondary trigger: Periodic re-evaluation (failsafe)
  - trigger: time_pattern
    minutes: "/1"
    id: periodic_check

  # Trigger when load shedding is disabled/enabled
  - trigger: state
    entity_id: !input load_shedding_disable
    id: override_changed

condition: []

action:
  # STEP 1: Initialize trackers on HA start
  - if:
      - condition: template
        value_template: "{{ trigger.id == 'ha_start' }}"
    then:
      # Initialize shed tracker if empty/invalid
      - if:
          - condition: template
            value_template: "{{ states(shed_loads_tracker) in ['', 'unknown', 'unavailable'] }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ shed_loads_tracker }}"
            data:
              value: "[]"

      # Initialize datetime tracker if unknown
      - if:
          - condition: template
            value_template: "{{ states(last_action_datetime) in ['unknown', 'unavailable'] }}"
        then:
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ last_action_datetime }}"
            data:
              datetime: "1970-01-01 00:00:00"

      # Clean up orphaned entity IDs from tracker
      - variables:
          valid_entity_ids: "{{ managed_loads | map(attribute='primary_entity') | list }}"
          current_shed_loads_list: >-
            {% set shed_json = states(shed_loads_tracker) %}
            {% if shed_json in ['', 'unknown', 'unavailable'] %}
              []
            {% else %}
              {{ shed_json | from_json | default([]) }}
            {% endif %}
          cleaned_shed_loads: >-
            {{ current_shed_loads_list | select('in', valid_entity_ids) | list }}

      # Update tracker if we removed any orphans
      - if:
          - condition: template
            value_template: "{{ current_shed_loads_list | length != cleaned_shed_loads | length }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ shed_loads_tracker }}"
            data:
              value: "{{ cleaned_shed_loads | to_json }}"

  # STEP 2: If load shedding disabled, restore all and exit
  - if:
      - condition: template
        value_template: "{{ load_shedding_disabled }}"
    then:
      # Restore all currently shed loads
      - repeat:
          for_each: "{{ currently_shed_loads }}"
          sequence:
            # Find load object by primary_entity
            - variables:
                entity_id: "{{ repeat.item }}"
                load: >-
                  {{ managed_loads | selectattr('primary_entity', 'eq', entity_id) | first | default(none) }}
                control_switch: "{{ load.get('control_switch', '') if load is not none else '' }}"
                control_entity: >-
                  {% if load is not none %}
                    {% if control_switch and control_switch | length > 0 %}
                      {{ control_switch }}
                    {% else %}
                      {{ entity_id }}
                    {% endif %}
                  {% else %}
                    {{ none }}
                  {% endif %}

            # Validate load found and control entity exists
            - condition: template
              value_template: "{{ load is not none and control_entity is not none }}"

            # Validate control entity state
            - condition: template
              value_template: "{{ states(control_entity) not in ['unknown', 'unavailable'] }}"

            # Turn on control entity
            - service: homeassistant.turn_on
              target:
                entity_id: "{{ control_entity }}"

      # Clear shed tracker
      - service: input_text.set_value
        target:
          entity_id: "{{ shed_loads_tracker }}"
        data:
          value: "[]"

      - stop: "Load shedding is disabled - all shed loads have been restored"

  # STEP 3: Validate configuration
  - condition: template
    value_template: >-
      {% if managed_loads | length == 0 %}
        {{ false }}
      {% endif %}

      {# Validate no duplicate primary entities #}
      {% set primary_entities = managed_loads | map(attribute='primary_entity') | list %}
      {% if primary_entities | unique | list | length != primary_entities | length %}
        {{ false }}
      {% endif %}

      {{ true }}

  # STEP 4: Clean up orphaned entities from tracker
  - variables:
      valid_entity_ids: "{{ managed_loads | map(attribute='primary_entity') | list }}"
      cleaned_shed_loads: "{{ currently_shed_loads | select('in', valid_entity_ids) | list }}"

  - if:
      - condition: template
        value_template: "{{ currently_shed_loads | length != cleaned_shed_loads | length }}"
    then:
      - service: input_text.set_value
        target:
          entity_id: "{{ shed_loads_tracker }}"
        data:
          value: "{{ cleaned_shed_loads | to_json }}"

      # Update currently_shed_loads variable for this run
      - variables:
          currently_shed_loads: "{{ cleaned_shed_loads }}"

  # STEP 5: Determine mode (shedding or restoration)
  - variables:
      power_over_shedding_threshold: "{{ current_power > shedding_threshold }}"
      power_under_restoration_threshold: "{{ current_power < restoration_threshold }}"

  # STEP 6: SHEDDING MODE
  - if:
      - condition: template
        value_template: "{{ power_over_shedding_threshold }}"
    then:
      # Wait for shedding delay to prevent transient spike reactions
      - if:
          - condition: template
            value_template: "{{ trigger.id == 'power_changed' }}"
        then:
          - delay: !input shedding_delay

      # Re-check power after delay (might have dropped)
      - variables:
          current_power_after_delay: "{{ states(total_power_sensor) | float(0) }}"

      - if:
          - condition: template
            value_template: "{{ current_power_after_delay > shedding_threshold }}"
        then:
          # Build candidate list for shedding
          - variables:
              candidates_to_shed: >-
                {% set ns = namespace(candidates=[]) %}
                {% for load in managed_loads %}
                  {% set primary_entity = load.primary_entity %}
                  {% set control_switch = load.get('control_switch', '') %}
                  {% set max_power = load.max_power | float(0) %}
                  {% set load_index = loop.index0 %}

                  {# Skip if max_power invalid #}
                  {% if max_power <= 0 %}
                    {% continue %}
                  {% endif %}

                  {# Determine control entity #}
                  {% if control_switch and control_switch | length > 0 %}
                    {% set control_entity = control_switch %}
                  {% else %}
                    {% set control_entity = primary_entity %}
                  {% endif %}

                  {# Validate control entity exists #}
                  {% if states(control_entity) in ['unknown', 'unavailable'] %}
                    {% continue %}
                  {% endif %}

                  {# Determine if load is ON based on primary entity type #}
                  {% set is_load_on = namespace(value=false) %}
                  {% set entity_domain = primary_entity.split('.')[0] %}

                  {% if entity_domain == 'climate' %}
                    {# For climate: check hvac_action attribute #}
                    {% set hvac_action = state_attr(primary_entity, 'hvac_action') %}
                    {% if hvac_action in ['heating', 'cooling'] %}
                      {% set is_load_on.value = true %}
                    {% endif %}
                  {% elif entity_domain == 'switch' %}
                    {# For switch: check state #}
                    {% if is_state(primary_entity, 'on') %}
                      {% set is_load_on.value = true %}
                    {% endif %}
                  {% endif %}

                  {# Skip if load is not ON #}
                  {% if not is_load_on.value %}
                    {% continue %}
                  {% endif %}

                  {# Add to candidates #}
                  {% set ns.candidates = ns.candidates + [{
                    'entity_id': primary_entity,
                    'index': load_index,
                    'power': max_power,
                    'control': control_entity
                  }] %}
                {% endfor %}

                {# Sort by index (descending) then power (descending) #}
                {% set sorted_by_power = ns.candidates | sort(attribute='power', reverse=true) %}
                {{ sorted_by_power | sort(attribute='index', reverse=true) }}

              # Calculate deficit
              power_deficit: "{{ current_power_after_delay - shedding_threshold }}"

          # Shed loads iteratively
          - variables:
              shed_entities: []
              remaining_deficit: "{{ power_deficit }}"

          - repeat:
              for_each: "{{ candidates_to_shed }}"
              sequence:
                # Only shed if still needed
                - condition: template
                  value_template: "{{ remaining_deficit > 0 }}"

                # Turn off control entity
                - service: homeassistant.turn_off
                  target:
                    entity_id: "{{ repeat.item.control }}"

                # Track this shed load
                - variables:
                    shed_entities: "{{ shed_entities + [repeat.item.entity_id] }}"
                    remaining_deficit: "{{ (remaining_deficit - repeat.item.power) | float }}"

          # Update tracker with newly shed loads
          - if:
              - condition: template
                value_template: "{{ shed_entities | length > 0 }}"
            then:
              - variables:
                  all_shed_loads: "{{ (currently_shed_loads + shed_entities) | unique | list }}"

              - service: input_text.set_value
                target:
                  entity_id: "{{ shed_loads_tracker }}"
                data:
                  value: "{{ all_shed_loads | to_json }}"

              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ last_action_datetime }}"
                data:
                  datetime: "{{ now() }}"

  # STEP 7: RESTORATION MODE
  - if:
      - condition: template
        value_template: "{{ power_under_restoration_threshold and currently_shed_loads | length > 0 }}"
    then:
      # Wait for restoration delay
      - if:
          - condition: template
            value_template: "{{ trigger.id == 'power_changed' }}"
        then:
          - delay: !input restoration_delay

      # Re-check power after delay (might have increased)
      - variables:
          current_power_after_delay: "{{ states(total_power_sensor) | float(0) }}"

      - if:
          - condition: template
            value_template: "{{ current_power_after_delay < restoration_threshold }}"
        then:
          # Check minimum shed duration
          - condition: template
            value_template: >-
              {{ seconds_since_last_action >= timedelta(**minimum_shed_duration).total_seconds() }}

          # Build restoration candidates
          - variables:
              candidates_to_restore: >-
                {% set ns = namespace(candidates=[]) %}
                {% for entity_id in currently_shed_loads %}
                  {# Find load object by primary_entity #}
                  {% set load_index = namespace(value=-1) %}
                  {% set load = namespace(obj=none) %}
                  {% for l in managed_loads %}
                    {% if l.primary_entity == entity_id %}
                      {% set load.obj = l %}
                      {% set load_index.value = loop.index0 %}
                    {% endif %}
                  {% endfor %}

                  {# Skip if load not found (removed from config) #}
                  {% if load.obj is none %}
                    {% continue %}
                  {% endif %}

                  {% set primary_entity = load.obj.primary_entity %}
                  {% set control_switch = load.obj.get('control_switch', '') %}
                  {% set max_power = load.obj.max_power | float(0) %}

                  {# Skip if max_power invalid #}
                  {% if max_power <= 0 %}
                    {% continue %}
                  {% endif %}

                  {# Determine control entity #}
                  {% if control_switch and control_switch | length > 0 %}
                    {% set control_entity = control_switch %}
                  {% else %}
                    {% set control_entity = primary_entity %}
                  {% endif %}

                  {# Validate control entity exists #}
                  {% if states(control_entity) in ['unknown', 'unavailable'] %}
                    {% continue %}
                  {% endif %}

                  {# Determine if load is OFF based on primary entity type #}
                  {% set is_load_off = namespace(value=false) %}
                  {% set entity_domain = primary_entity.split('.')[0] %}

                  {% if entity_domain == 'climate' %}
                    {# For climate: check hvac_action attribute #}
                    {% set hvac_action = state_attr(primary_entity, 'hvac_action') %}
                    {% if hvac_action in ['idle', 'off'] or hvac_action is none %}
                      {% set is_load_off.value = true %}
                    {% endif %}
                  {% elif entity_domain == 'switch' %}
                    {# For switch: check state #}
                    {% if is_state(primary_entity, 'off') %}
                      {% set is_load_off.value = true %}
                    {% endif %}
                  {% endif %}

                  {# Skip if load is not OFF #}
                  {% if not is_load_off.value %}
                    {% continue %}
                  {% endif %}

                  {# Add to candidates #}
                  {% set ns.candidates = ns.candidates + [{
                    'entity_id': primary_entity,
                    'index': load_index.value,
                    'power': max_power,
                    'control': control_entity
                  }] %}
                {% endfor %}

                {# Sort by index (ascending) then power (ascending) #}
                {% set sorted_by_power = ns.candidates | sort(attribute='power') %}
                {{ sorted_by_power | sort(attribute='index') }}

              # Calculate available budget
              available_budget: "{{ restoration_threshold - current_power_after_delay }}"

          # Restore loads iteratively
          - variables:
              power_accumulator: "{{ current_power_after_delay }}"
              restored_entities: []

          - repeat:
              for_each: "{{ candidates_to_restore }}"
              sequence:
                # Check if we have budget for this load
                - condition: template
                  value_template: "{{ repeat.item.power <= (restoration_threshold - power_accumulator) }}"

                # Turn on control entity
                - service: homeassistant.turn_on
                  target:
                    entity_id: "{{ repeat.item.control }}"

                # Track restoration
                - variables:
                    power_accumulator: "{{ (power_accumulator + repeat.item.power) | float }}"
                    restored_entities: "{{ restored_entities + [repeat.item.entity_id] }}"

          # Update tracker (remove restored loads)
          - if:
              - condition: template
                value_template: "{{ restored_entities | length > 0 }}"
            then:
              - variables:
                  remaining_shed_loads: >-
                    {{ currently_shed_loads | reject('in', restored_entities) | list }}

              - service: input_text.set_value
                target:
                  entity_id: "{{ shed_loads_tracker }}"
                data:
                  value: "{{ remaining_shed_loads | to_json }}"

              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ last_action_datetime }}"
                data:
                  datetime: "{{ now() }}"

mode: queued
max: 10
max_exceeded: silent
