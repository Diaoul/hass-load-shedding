blueprint:
  name: âš¡ Intelligent Load Shedding
  description: |
    Proactive load management to prevent exceeding power capacity limits.

    **Features:**
    - âš¡ Real-time power monitoring
    - ðŸŽ¯ Priority-based load shedding (5 levels)
    - ðŸ”„ Intelligent load restoration
    - ðŸ›¡ï¸ Configurable safety margins
    - ðŸš« Anti-flapping protection
    - ðŸ”“ Manual override support
    - ðŸ“ Structured load configuration

    **How it works:**
    1. Monitors total power consumption (e.g., from Linky meter)
    2. Sheds lowest-priority loads when approaching capacity (default: 90%)
    3. Restores highest-priority loads when power drops (default: 80%)
    4. Prevents rapid on/off cycling with time delays and hysteresis

    **Configuration:** Use the structured load form - only 2 global helpers required.

    **Requirements:** Home Assistant 2025.7.0 or later
  domain: automation
  input:
    power_monitoring:
      name: Power Monitoring
      icon: mdi:flash
      collapsed: false
      input:
        total_power_sensor:
          name: ðŸ“Š Total Power Consumption Sensor
          description: Sensor measuring total household power consumption (e.g., Linky meter, whole-home energy monitor)
          selector:
            entity:
              filter:
                - domain: sensor
                  device_class: power
              multiple: false

        max_power_capacity:
          name: ðŸ”Œ Maximum Power Capacity
          description: Maximum power capacity in Watts (e.g., 9000W for 45A @ 230V single-phase, 12000W for 60A)
          default: 9000
          selector:
            number:
              min: 1000
              max: 50000
              step: 100
              unit_of_measurement: "W"
              mode: box

        safety_margin_percent:
          name: ðŸ›¡ï¸ Safety Margin Percentage
          description: |
            Start shedding loads when consumption reaches this percentage of max capacity.
            Example: 90% means shed at 8100W if max is 9000W.
            Higher values = more proactive shedding.
          default: 90
          selector:
            number:
              min: 50
              max: 100
              step: 1
              unit_of_measurement: "%"
              mode: slider

        restoration_margin_percent:
          name: ðŸ”„ Restoration Margin Percentage
          description: |
            Only restore loads when consumption is below this percentage.
            Should be lower than safety margin to prevent flapping.
            Example: 80% means restore at 7200W if max is 9000W.
          default: 80
          selector:
            number:
              min: 50
              max: 100
              step: 1
              unit_of_measurement: "%"
              mode: slider

    load_configuration:
      name: Load Configuration
      icon: mdi:lightning-bolt-circle
      collapsed: false
      input:
        managed_loads:
          name: ðŸŽ¯ Managed Loads
          description: |
            Configure each load you want to manage.
            Click "Add Item" to add a new load.

            **Priority is determined by order:**
            - Loads at the top of the list have highest priority (shed last)
            - Loads at the bottom have lowest priority (shed first)

            Use drag & drop to reorder loads and adjust priorities.
          default: []
          selector:
            object:
              multiple: true
              label_field: name
              fields:
                name:
                  label: Load Name
                  selector:
                    text:

                switch_entity:
                  label: Switch Entity
                  selector:
                    entity:
                      domain: switch
                      multiple: false

                max_power:
                  label: Estimated Power Consumption
                  description: >
                    Rated or estimated power consumption in Watts when this load is ON.
                    This value is used for deficit calculations and restoration budgeting.
                  selector:
                    number:
                      min: 1
                      max: 50000
                      step: 1
                      unit_of_measurement: "W"
                      mode: box

                status_sensor:
                  label: Status Sensor (Optional)
                  description: >
                    OPTIONAL: Binary sensor or sensor that indicates if this load is currently ON.

                    - If provided: Only shed loads when status is 'on', skip when 'off'

                    - If NOT provided: Always consider load as potential candidate

                    Accepts binary_sensor (on/off) or regular sensor with 'on'/'off' states.
                  default: ""
                  selector:
                    entity:
                      filter:
                        - domain: binary_sensor
                        - domain: sensor
                      multiple: false

    timing_and_stability:
      name: Timing & Stability
      icon: mdi:clock-outline
      collapsed: true
      input:
        shedding_delay:
          name: â±ï¸ Shedding Delay
          description: Wait this long after exceeding threshold before shedding (prevents transient spikes from causing shedding)
          default:
            hours: 0
            minutes: 0
            seconds: 10
          selector:
            duration:
              enable_day: false

        restoration_delay:
          name: â±ï¸ Restoration Delay
          description: Wait this long after dropping below threshold before restoring loads
          default:
            hours: 0
            minutes: 1
            seconds: 0
          selector:
            duration:
              enable_day: false

        minimum_shed_duration:
          name: â±ï¸ Minimum Shed Duration
          description: Once a load is shed, keep it off for at least this long (prevents rapid cycling)
          default:
            hours: 0
            minutes: 5
            seconds: 0
          selector:
            duration:
              enable_day: false

    manual_overrides:
      name: Manual Overrides
      icon: mdi:hand-back-right
      collapsed: true
      input:
        load_shedding_disable:
          name: ðŸ›‘ Disable Load Shedding
          description: |
            Toggle to completely disable load shedding.
            When enabled, all shed loads are immediately restored.

            Create a helper [here](https://my.home-assistant.io/redirect/helpers/).
          default: []
          selector:
            entity:
              filter:
                - domain:
                    - input_boolean
                    - switch
                    - binary_sensor
              multiple: false

    tracking_helpers:
      name: Tracking Helpers (Required)
      icon: mdi:database
      collapsed: true
      input:
        shed_loads_tracker:
          name: ðŸ“ Currently Shed Loads Tracker
          description: |
            `required`

            Input text helper to track which loads are currently shed by automation.
            Stores JSON array of load names (e.g., ["Water Heater", "EV Charger"]).

            **Initialize as empty string.**

            Create helper [here](https://my.home-assistant.io/redirect/helpers/).
          selector:
            entity:
              filter:
                - domain: input_text
              multiple: false

        last_action_datetime:
          name: â° Last Action DateTime Tracker
          description: |
            `required`

            Input datetime helper to track when last shed/restore action occurred.
            Used for minimum shed duration enforcement.

            **Initialize to any datetime (e.g., 1970-01-01 00:00:00).**

            Create helper [here](https://my.home-assistant.io/redirect/helpers/).
          selector:
            entity:
              filter:
                - domain: input_datetime
              multiple: false

variables:
  # Input assignments - power monitoring
  total_power_sensor: !input total_power_sensor
  max_power: !input max_power_capacity
  safety_margin: !input safety_margin_percent
  restoration_margin: !input restoration_margin_percent

  # Input assignments - loads
  managed_loads: !input managed_loads

  # Input assignments - timing
  shedding_delay: !input shedding_delay
  restoration_delay: !input restoration_delay
  minimum_shed_duration: !input minimum_shed_duration

  # Input assignments - overrides
  load_shedding_disable: !input load_shedding_disable

  # Input assignments - tracking
  shed_loads_tracker: !input shed_loads_tracker
  last_action_datetime: !input last_action_datetime

  # Calculated thresholds
  shedding_threshold: "{{ (max_power * (safety_margin / 100)) | int }}"
  restoration_threshold: "{{ (max_power * (restoration_margin / 100)) | int }}"

  # Current state
  current_power: "{{ states(total_power_sensor) | float(0) }}"
  load_shedding_disabled: >-
    {{ load_shedding_disable | length > 0 and is_state(load_shedding_disable, 'on') }}

  # Currently shed loads list (parse JSON array of load names)
  currently_shed_loads: >-
    {% set shed_json = states(shed_loads_tracker) %}
    {% if shed_json in ['', 'unknown', 'unavailable'] %}
      []
    {% else %}
      {{ shed_json | from_json | default([]) }}
    {% endif %}

  # Last action timestamp
  last_action_time: >-
    {% set dt_state = states(last_action_datetime) %}
    {% if dt_state in ['unknown', 'unavailable'] %}
      {{ as_timestamp('1970-01-01 00:00:00') }}
    {% else %}
      {{ as_timestamp(dt_state) }}
    {% endif %}

  # Time since last action
  seconds_since_last_action: >-
    {{ (now().timestamp() - last_action_time) | int }}

trigger:
  # Trigger on HA start
  - trigger: homeassistant
    event: start
    id: ha_start

  # Primary trigger: Power consumption changes
  - trigger: state
    entity_id: !input total_power_sensor
    id: power_changed

  # Secondary trigger: Periodic re-evaluation (failsafe)
  - trigger: time_pattern
    minutes: "/1"
    id: periodic_check

  # Trigger when load shedding is disabled/enabled
  - trigger: state
    entity_id: !input load_shedding_disable
    id: override_changed

condition: []

action:
  # STEP 1: Initialize trackers on HA start
  - if:
      - condition: template
        value_template: "{{ trigger.id == 'ha_start' }}"
    then:
      # Initialize shed tracker if empty/invalid
      - if:
          - condition: template
            value_template: "{{ states(shed_loads_tracker) in ['', 'unknown', 'unavailable'] }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ shed_loads_tracker }}"
            data:
              value: "[]"

      # Initialize datetime tracker if unknown
      - if:
          - condition: template
            value_template: "{{ states(last_action_datetime) in ['unknown', 'unavailable'] }}"
        then:
          - service: input_datetime.set_datetime
            target:
              entity_id: "{{ last_action_datetime }}"
            data:
              datetime: "1970-01-01 00:00:00"

      # Clean up orphaned load names from tracker
      - variables:
          valid_load_names: "{{ managed_loads | map(attribute='name') | list }}"
          current_shed_loads_list: >-
            {% set shed_json = states(shed_loads_tracker) %}
            {% if shed_json in ['', 'unknown', 'unavailable'] %}
              []
            {% else %}
              {{ shed_json | from_json | default([]) }}
            {% endif %}
          cleaned_shed_loads: >-
            {{ current_shed_loads_list | select('in', valid_load_names) | list }}

      # Update tracker if we removed any orphans
      - if:
          - condition: template
            value_template: "{{ current_shed_loads_list | length != cleaned_shed_loads | length }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ shed_loads_tracker }}"
            data:
              value: "{{ cleaned_shed_loads | to_json }}"

  # STEP 2: If load shedding disabled, restore all and exit
  - if:
      - condition: template
        value_template: "{{ load_shedding_disabled }}"
    then:
      # Restore all currently shed loads
      - repeat:
          for_each: "{{ currently_shed_loads }}"
          sequence:
            # Find load object by name
            - variables:
                load_name: "{{ repeat.item }}"
                load: >-
                  {{ managed_loads | selectattr('name', 'eq', load_name) | first | default(none) }}
                switch_entity: "{{ load.switch_entity if load is not none else none }}"

            # Validate load found and switch exists
            - condition: template
              value_template: "{{ load is not none and switch_entity is not none }}"

            # Validate switch entity state
            - condition: template
              value_template: "{{ states(switch_entity) in ['on', 'off'] }}"

            # Turn on switch if currently off
            - if:
                - condition: template
                  value_template: "{{ is_state(switch_entity, 'off') }}"
              then:
                - service: homeassistant.turn_on
                  target:
                    entity_id: "{{ switch_entity }}"

      # Clear shed tracker
      - service: input_text.set_value
        target:
          entity_id: "{{ shed_loads_tracker }}"
        data:
          value: "[]"

      - stop: "Load shedding is disabled - all shed loads have been restored"

  # STEP 3: Validate configuration
  - condition: template
    value_template: >-
      {% if managed_loads | length == 0 %}
        {{ false }}
      {% endif %}

      {# Validate no duplicate load names #}
      {% set load_names = managed_loads | map(attribute='name') | list %}
      {% if load_names | unique | list | length != load_names | length %}
        {{ false }}
      {% endif %}

      {# Validate no duplicate switch entities #}
      {% set switches = managed_loads | map(attribute='switch_entity') | list %}
      {% if switches | unique | list | length != switches | length %}
        {{ false }}
      {% endif %}

      {{ true }}

  # STEP 4: Determine mode (shedding or restoration)
  - variables:
      power_over_shedding_threshold: "{{ current_power > shedding_threshold }}"
      power_under_restoration_threshold: "{{ current_power < restoration_threshold }}"

  # STEP 5: SHEDDING MODE
  - if:
      - condition: template
        value_template: "{{ power_over_shedding_threshold }}"
    then:
      # Wait for shedding delay to prevent transient spike reactions
      - if:
          - condition: template
            value_template: "{{ trigger.id == 'power_changed' }}"
        then:
          - delay: !input shedding_delay

      # Re-check power after delay (might have dropped)
      - variables:
          current_power_after_delay: "{{ states(total_power_sensor) | float(0) }}"

      - if:
          - condition: template
            value_template: "{{ current_power_after_delay > shedding_threshold }}"
        then:
          # Build candidate list for shedding
          - variables:
              candidates_to_shed: >-
                {% set ns = namespace(candidates=[]) %}
                {% for load in managed_loads %}
                  {% set load_name = load.name %}
                  {% set load_index = loop.index0 %}
                  {% set switch_entity = load.switch_entity %}
                  {% set status_sensor = load.get('status_sensor', '') %}
                  {% set max_power = load.max_power | float(0) %}

                  {# Skip if max_power is invalid or zero #}
                  {% if max_power <= 0 %}
                    {% continue %}
                  {% endif %}

                  {# Skip if switch entity invalid #}
                  {% if not states(switch_entity) in ['on', 'off'] %}
                    {% continue %}
                  {% endif %}

                  {# Determine if load is currently ON #}
                  {% set is_load_on = namespace(value=false) %}

                  {% if status_sensor and status_sensor | length > 0 %}
                    {# Status sensor provided - use it to determine state #}
                    {% set status_state = states(status_sensor) %}

                    {# Skip if status sensor unavailable/unknown #}
                    {% if status_state in ['unknown', 'unavailable', ''] %}
                      {% continue %}
                    {% endif %}

                    {# Check if status sensor reports ON #}
                    {% if status_state in ['on', 'On', 'ON', '1', 'true', 'True'] %}
                      {% set is_load_on.value = true %}
                    {% endif %}
                  {% else %}
                    {# No status sensor - check switch entity state #}
                    {% if is_state(switch_entity, 'on') %}
                      {% set is_load_on.value = true %}
                    {% endif %}
                  {% endif %}

                  {# Skip if load is not ON (nothing to shed) #}
                  {% if not is_load_on.value %}
                    {% continue %}
                  {% endif %}

                  {# Add to candidates with max_power #}
                  {% set ns.candidates = ns.candidates + [{
                    'name': load_name,
                    'index': load_index,
                    'power': max_power,
                    'switch': switch_entity
                  }] %}
                {% endfor %}

                {# Sort: highest index first (lowest priority = shed first), highest power first within same priority #}
                {% set sorted_by_power = ns.candidates | sort(attribute='power', reverse=true) %}
                {{ sorted_by_power | sort(attribute='index', reverse=true) }}

              # Calculate deficit
              power_deficit: "{{ current_power_after_delay - shedding_threshold }}"

          # Shed loads iteratively
          - variables:
              shed_names: []
              remaining_deficit: "{{ power_deficit }}"

          - repeat:
              for_each: "{{ candidates_to_shed }}"
              sequence:
                # Only shed if still needed
                - condition: template
                  value_template: "{{ remaining_deficit > 0 }}"

                # Turn off switch
                - service: homeassistant.turn_off
                  target:
                    entity_id: "{{ repeat.item.switch }}"

                # Track this shed load
                - variables:
                    shed_names: "{{ shed_names + [repeat.item.name] }}"
                    remaining_deficit: "{{ (remaining_deficit - repeat.item.power) | float }}"

          # Update tracker with newly shed loads
          - if:
              - condition: template
                value_template: "{{ shed_names | length > 0 }}"
            then:
              - variables:
                  all_shed_loads: "{{ (currently_shed_loads + shed_names) | unique | list }}"

              - service: input_text.set_value
                target:
                  entity_id: "{{ shed_loads_tracker }}"
                data:
                  value: "{{ all_shed_loads | to_json }}"

              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ last_action_datetime }}"
                data:
                  datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

  # STEP 6: RESTORATION MODE
  - if:
      - condition: template
        value_template: "{{ power_under_restoration_threshold and currently_shed_loads | length > 0 }}"
    then:
      # Wait for restoration delay
      - if:
          - condition: template
            value_template: "{{ trigger.id == 'power_changed' }}"
        then:
          - delay: !input restoration_delay

      # Re-check power after delay (might have increased)
      - variables:
          current_power_after_delay: "{{ states(total_power_sensor) | float(0) }}"

      - if:
          - condition: template
            value_template: "{{ current_power_after_delay < restoration_threshold }}"
        then:
          # Check minimum shed duration
          - condition: template
            value_template: >-
              {{ seconds_since_last_action >= minimum_shed_duration.total_seconds() }}

          # Build restoration candidates
          - variables:
              candidates_to_restore: >-
                {% set ns = namespace(candidates=[]) %}
                {% for load_name in currently_shed_loads %}
                  {# Find the load object and its index #}
                  {% set load_index = namespace(value=-1) %}
                  {% set load = namespace(obj=none) %}
                  {% for l in managed_loads %}
                    {% if l.name == load_name %}
                      {% set load.obj = l %}
                      {% set load_index.value = loop.index0 %}
                    {% endif %}
                  {% endfor %}

                  {# Skip if load not found (was removed from config) #}
                  {% if load.obj is none %}
                    {% continue %}
                  {% endif %}

                  {# Extract load properties #}
                  {% set switch_entity = load.obj.switch_entity %}
                  {% set status_sensor = load.obj.get('status_sensor', '') %}
                  {% set max_power = load.obj.max_power | float(0) %}

                  {# Skip if max_power invalid #}
                  {% if max_power <= 0 %}
                    {% continue %}
                  {% endif %}

                  {# Validate switch entity exists #}
                  {% if not states(switch_entity) in ['on', 'off'] %}
                    {% continue %}
                  {% endif %}

                  {# Determine if load is currently OFF (eligible for restoration) #}
                  {% set is_load_off = namespace(value=false) %}

                  {% if status_sensor and status_sensor | length > 0 %}
                    {# Status sensor provided - use it to determine state #}
                    {% set status_state = states(status_sensor) %}

                    {# Skip if status sensor unavailable/unknown #}
                    {% if status_state in ['unknown', 'unavailable', ''] %}
                      {% continue %}
                    {% endif %}

                    {# Check if status sensor reports OFF #}
                    {% if status_state in ['off', 'Off', 'OFF', '0', 'false', 'False'] %}
                      {% set is_load_off.value = true %}
                    {% endif %}
                  {% else %}
                    {# No status sensor - check switch entity state #}
                    {% if is_state(switch_entity, 'off') %}
                      {% set is_load_off.value = true %}
                    {% endif %}
                  {% endif %}

                  {# Skip if load is not OFF (manually turned on or already restored) #}
                  {% if not is_load_off.value %}
                    {% continue %}
                  {% endif %}

                  {# Add to candidates with max_power #}
                  {% set ns.candidates = ns.candidates + [{
                    'name': load_name,
                    'index': load_index.value,
                    'power': max_power,
                    'switch': switch_entity
                  }] %}
                {% endfor %}

                {# Sort: lowest index first (highest priority = restore first), lowest power first within same priority #}
                {% set sorted_by_power = ns.candidates | sort(attribute='power') %}
                {{ sorted_by_power | sort(attribute='index') }}

              # Calculate available budget
              available_budget: "{{ restoration_threshold - current_power_after_delay }}"

          # Restore loads iteratively
          - variables:
              power_accumulator: "{{ current_power_after_delay }}"
              restored_names: []

          - repeat:
              for_each: "{{ candidates_to_restore }}"
              sequence:
                # Check if we have budget for this load
                - condition: template
                  value_template: "{{ repeat.item.power <= (restoration_threshold - power_accumulator) }}"

                # Turn on switch
                - service: homeassistant.turn_on
                  target:
                    entity_id: "{{ repeat.item.switch }}"

                # Track restoration
                - variables:
                    power_accumulator: "{{ (power_accumulator + repeat.item.power) | float }}"
                    restored_names: "{{ restored_names + [repeat.item.name] }}"

          # Update tracker (remove restored loads)
          - if:
              - condition: template
                value_template: "{{ restored_names | length > 0 }}"
            then:
              - variables:
                  remaining_shed_loads: >-
                    {{ currently_shed_loads | reject('in', restored_names) | list }}

              - service: input_text.set_value
                target:
                  entity_id: "{{ shed_loads_tracker }}"
                data:
                  value: "{{ remaining_shed_loads | to_json }}"

              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ last_action_datetime }}"
                data:
                  datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

mode: queued
max: 10
max_exceeded: silent
